setwd("/mnt/disks/rserver-hdd/projects/Nick/B-cells/CD19_B-cells/Standardized_CTL_SLEDAI_NA/")
load("GSE10325_CD19_Standardized_CTL_SLEDAI_NA_analysis_parameters.RData")

saveTOMFileBase = paste0(file.base,"_SP22_10K_25Oct2017") #### change
sigTrait <- "SLEDAI" #### change


# You will need to check the rownames of the deepsplits ~ line 100
# You will also need to change your final choice of deep split and other options ~ line 400

## PART 5 Correlate modules to clinical traits and select final modules

###############################################################################################################
### CONCEPTUAL OVERVIEW
# We first recut the blocks of clustered weighted, co-expression gene using all four levels
# of deep split (DS) and generally inspect the per-probe module assignment along with color
# bars of correlation to all clinical traits accompanying the dataset. It is these four DS
# recuts we scrutinize using these subsequent figures and calculations in order to choose the
# deep split that provides the most valuable modules.
#
# 1. We correlate the module eigengenes (MEs) of each DS to clinical traits. Here we're looking for the maximum 
# number of modules significantly correlated to our clinical trait of greatest interest, usually SLEDAI, but
# all correlations are later stored and reported in heatmaps and data tables.
#
# 2. We annotate genes within the four DS modules using both GO and AMPEL BIG-C categories,
# with the goal of looking for a DS that yields modules discretely capturing
# single categories.
#
# 3. Dendrograms are generated for each deep split, which are used more to help establish if modules are too
# small or need to be merged. The case to merge modules can also be built by inspecting how much
# GO or BIGC annotation they share. 
#
# 4. Heatmaps are automatically generated for every module in every deepsplit, and stored in a subdirectory.
#
# 5. We move from the module level to the gene level, calculating the kME & kIM and look at per-module
# statistics and figures of these two.
#
# 6. Recall the ME is calculated using the average gene counts of all samples, so for each module we inspect
# the contribution of each sample to that module's averaged counts. Historically we've found many modules are
# generated due to the contribution of a single sample very strongly expressing those genes. Clearly these
# modules must be disregarded because they contain genes that don't adequately describe the difference
# between diseased and normal
#
# 7. Per ME we inspect the scatterplots of module membership (kIM) vs. correlation to significant clinical trait.
# This is more a visual confirmation of "module quality", a characteristic that one day needs to be quantified.
#
# 8. We include a similar scatterplot of the grey module, ensuring interesting genes weren't lost to the dump module.
#
# 9. The genes with gene annotation, module color assignment, gene-level correlations to clinical traits,
# kMEs and kIMs are bound into the final geneLists.
#
# 10. geneLists are output to a Microsoft Excel workbook, including a summary sheet, room for figures, 
# and workseet for each module gene list.
#
###############################################################################################################

library(WGCNA)
library(Hmisc) # contains capitalize function
#library(a4)
options(stringsAsFactors = FALSE);
allowWGCNAThreads()

# Load project level output
setwd(analysisDir)
load("part1-final-objects.RData")
eset <- eset.wgcna
rm(eset.wgcna)
pData <- pData(eset)
fData <- fData(eset)

load(paste0(saveTOMFileBase,"_NET.RData"))
load(paste0(saveTOMFileBase,"_TOM_settings.RData"))
load("projectName.RData")

# Load recut module output
load("experimentName.recut.RData")
experimentDir<-paste0(analysisDir,experimentName.recut)
setwd(experimentDir)
load("recut.DS-DS1-DS4.modules.and.genes.RData")

########################################################################################
# SET CLINICAL TRAIT OF MOST INTEREST, USUALLY SLEDAI. ALSO SET GLOBAL P-VAL

p_val <- 0.2
moduleColors.batch <- c("moduleColors", "moduleColors.DS1", "moduleColors.DS2",
                        "moduleColors.DS3", "moduleColors.DS4")
moduleCor.batch <- c("moduleCor","moduleCor.DS1","moduleCor.DS2","moduleCor.DS3","moduleCor.DS4")
MEs.batch <- c("MEs", "MEs.DS1", "MEs.DS2", "MEs.DS3", "MEs.DS4")

########################################################################################
# DS-DS1-DS4 Calculate module correlations to clinical traits
# 08-03-17 RDR: Note we're saving the modules generated by all four deep split (DS) recuts as well
# as the modules originally created during TOM generation. The "DS-orig" is almost always a DS of 3,
# but I do refer to it here as simply "DS", followed by the four recuts of DS1, DS2, DS3, DS4 (DS1-DS4)
# In theory the deepsplit function within the TOM() function should generate results identical to
# those from the recut() function!


colnames(eset)
rownames(datTraits)
rownames(datExpr)
rownames(MEs)
rownames(MEs.DS1)
rownames(MEs.DS2)
rownames(MEs.DS3)
rownames(MEs.DS4)
#MEs.DS1<-MEs.DS1[order(rownames(MEs.DS1),decreasing=TRUE),]
#MEs.DS2<-MEs.DS2[order(rownames(MEs.DS2),decreasing=TRUE),]
#MEs.DS3<-MEs.DS3[order(rownames(MEs.DS3),decreasing=TRUE),]
#MEs.DS4<-MEs.DS4[order(rownames(MEs.DS4),decreasing=TRUE),]

# Graphics parameters for module corr
saveFile <-  TRUE # Specify if output plots will be saved
plotMar <- c(8, 6, 4, 2)
xLabels <- colnames(datTraits)
xColorOffset <- 0
xLabelsAngle <- 45
cex.lab.x <- 1
cex.lab.y <- 0.5
text.size <- 0.2
pngWidth <- 1200
pngHeight <- 1000

dev.off()

setwd(analysisDir)
setStorageDir <- dget(paste0(scriptDir,"wgcna/set.storage.directory.R"))
outputStorage <- setStorageDir( c(experimentName.recut,"plots" ) )

source(paste0(scriptDir,"wgcna/wgcna.cor.modules.traits.R"))

rm(saveFile,plotMar,xLabels,xColorOffset,xLabelsAngle,cex.lab.x,cex.lab.y,text.size)

setwd(analysisDir)

########################################################################################
# GET A QUICK SNAPSHOT OF SIGNIFICANT CORRELATION TO CLINICAL TRAIT OF MOST INTEREST

sig.orig <- length(which(moduleCor[,paste(sigTrait,".p",sep="")]<p_val))
sig.DS1 <- length(which(moduleCor.DS1[,paste(sigTrait,".p",sep="")]<p_val)) 
sig.DS2 <- length(which(moduleCor.DS2[,paste(sigTrait,".p",sep="")]<p_val))
sig.DS3 <- length(which(moduleCor.DS3[,paste(sigTrait,".p",sep="")]<p_val))
sig.DS4 <- length(which(moduleCor.DS4[,paste(sigTrait,".p",sep="")]<p_val))

print(paste(sig.orig, " modules sig to ",sigTrait,": DS",TOM.settings["deepSplit"]," TOM cut",sep=""))
print(paste(sig.DS1, " modules sig to ",sigTrait,": DS1 cut",sep=""))
print(paste(sig.DS2, " modules sig to ",sigTrait,": DS2 cut",sep=""))
print(paste(sig.DS3, " modules sig to ",sigTrait,": DS3 cut",sep=""))
print(paste(sig.DS4, " modules sig to ",sigTrait,": DS4 cut",sep=""))

rm(sig.orig,sig.DS1,sig.DS2,sig.DS3,sig.DS4)

########################################################################################
# BEGIN CREATION OF GENE LISTS

fData$fData.order <- rep(1:nrow(fData))
geneList.DS <- cbind( moduleColors, fData )
geneList.DS1 <- cbind( moduleColors.DS1, fData )
geneList.DS2 <- cbind( moduleColors.DS2, fData )
geneList.DS3 <- cbind( moduleColors.DS3, fData )
geneList.DS4 <- cbind( moduleColors.DS4, fData )

##############################################################################
# ANNOTATE WITH BIGC

setwd(analysisDir)
bigc <- read.delim("BIGCv4-3_NSG_17Aug2017.txt",sep = "\t",header = TRUE)

geneList.DS.1 <- merge( geneList.DS, bigc[,1:3], by.x="geneEntrezID", by.y="Entrez_ID", all.x=TRUE, all.y=FALSE )
geneList.DS.1 <- geneList.DS.1[order(geneList.DS.1$fData.order),]
geneList.DS <- geneList.DS.1
rm(geneList.DS.1)

geneList.DS1.1 <- merge( geneList.DS1, bigc[,1:3], by.x="geneEntrezID", by.y="Entrez_ID", all.x=TRUE, all.y=FALSE )
geneList.DS1.1 <- geneList.DS1.1[order(geneList.DS1.1$fData.order),]
geneList.DS1 <- geneList.DS1.1
rm(geneList.DS1.1)

geneList.DS2.1 <- merge( geneList.DS2, bigc[,1:3], by.x="geneEntrezID", by.y="Entrez_ID", all.x=TRUE, all.y=FALSE )
geneList.DS2.1 <- geneList.DS2.1[order(geneList.DS2.1$fData.order),]
geneList.DS2 <- geneList.DS2.1
rm(geneList.DS2.1)

geneList.DS3.1 <- merge( geneList.DS3, bigc[,1:3], by.x="geneEntrezID", by.y="Entrez_ID", all.x=TRUE, all.y=FALSE )
geneList.DS3.1 <- geneList.DS3.1[order(geneList.DS3.1$fData.order),]
geneList.DS3 <- geneList.DS3.1
rm(geneList.DS3.1)

geneList.DS4.1 <- merge( geneList.DS4, bigc[,1:3], by.x="geneEntrezID", by.y="Entrez_ID", all.x=TRUE, all.y=FALSE )
geneList.DS4.1 <- geneList.DS4.1[order(geneList.DS4.1$fData.order),]
geneList.DS4 <- geneList.DS4.1
rm(geneList.DS4.1)

geneList.batch <- c("geneList.DS","geneList.DS1","geneList.DS2","geneList.DS3","geneList.DS4")

########################################################################################
# SAVE EARLY GENE LISTS

outputStorage <- setStorageDir( c(experimentName.recut ) )
save(geneList.DS, geneList.DS1,geneList.DS2,geneList.DS3,geneList.DS4,file="geneLists.RData")
setwd(analysisDir)

########################################################################################
# ANNOTATE WITH GO
# 08-01-17 RDR: This is throwing the error "all entries of 'x' must be nonnegative and finite"
# This may have something to do with large numbers exceeding the integer data type capacity
# We can try this again per module. Recall we really use BigC, but I bring along GO
# annotations as a legacy item, possible to compare with other published results?

# GOenr.DS = GOenrichmentAnalysis(geneList.DS$moduleColors, as.character(geneList.DS$entrezgene), organism = "human", nBestP = 10);
# GO.DS = GOenr.DS$bestPTerms[[4]]$enrichment
# 
# GOenr.DS1 = GOenrichmentAnalysis(geneList.DS1$moduleColors.DS1, geneList.DS1$entrezgene, organism = "human", nBestP = 10);
# GO.DS1 = GOenr.DS1$bestPTerms[[4]]$enrichment
# 
# GOenr.DS2 = GOenrichmentAnalysis(geneList.DS2$moduleColors.DS2, geneList.DS2$entrezgene, organism = "human", nBestP = 10);
# GO.DS2 = GOenr.DS2$bestPTerms[[4]]$enrichment
# 
# GOenr.DS3 = GOenrichmentAnalysis(geneList.DS3$moduleColors.DS1, geneList.DS3$entrezgene, organism = "human", nBestP = 10);
# GO.DS3 = GOenr.DS3$bestPTerms[[4]]$enrichment
# 
# GOenr.DS4 = GOenrichmentAnalysis(geneList.DS1$moduleColors.DS4, geneList.DS4$entrezgene, organism = "human", nBestP = 10);
# GO.DS4 = GOenr.DS4$bestPTerms[[4]]$enrichment

########################################################################################
## PLOT DENDROGRAM OF ALL MODULES FOR VARIOUS DEEPSPLITS

outputStorage <- setStorageDir( c(experimentName.recut,"plots" ) )

# Load the plot dendrogram function
source(paste0(scriptDir,"wgcna/wgcna.deepsplits.dendros.R"))

# parMar sets bottom, left, top, right margins

# Original DS3 cut
plotDendro(datExpr, moduleColors, moduleCor, sigTrait, parMar=c(6,10,2,14), p_val, cex=0.7, deepSplit="DS3",
          chart.filename="dendro.TOMDS3.png", pngWidth=1400, pngHeight=1000, saveFile=TRUE)

# DS1 recut
plotDendro(datExpr, moduleColors.DS1, moduleCor.DS1, sigTrait, parMar=c(6,10,2,14), p_val, cex=0.7, deepSplit="DS1",
           chart.filename="dendro.DS1.png", pngWidth=1400, pngHeight=1000, saveFile=TRUE)

# DS2 recut
plotDendro(datExpr, moduleColors.DS2, moduleCor.DS2, sigTrait, parMar=c(6,10,2,14), p_val, cex=0.7, deepSplit="DS2",
           chart.filename="dendro.DS2.png", pngWidth=1400, pngHeight=1000, saveFile=TRUE)

# DS3 recut
plotDendro(datExpr, moduleColors.DS3, moduleCor.DS3, sigTrait, parMar=c(6,10,2,14), p_val, cex=0.7, deepSplit="DS3",
           chart.filename="dendro.DS3.png", pngWidth=1400, pngHeight=1000, saveFile=TRUE)

# DS4 recut
plotDendro(datExpr, moduleColors.DS4, moduleCor.DS4, sigTrait, parMar=c(6,10,2,14), p_val, cex=0.7, deepSplit="DS4",
           chart.filename="dendro.DS4.png", pngWidth=1400, pngHeight=1000, saveFile=TRUE)

setwd(analysisDir)

########################################################################################
## GENERATE HEATMAPS OF PROBE/GENE EXPRESSION IN ALL DEEPSPLIT MODULES

# Load the heatmap function
source(paste0(scriptDir,"wgcna/wgcna.module.genes.heatmap.R"))

# Save the many heatmaps in their own directory
setStorageDir <- dget(paste0(scriptDir,"wgcna/set.storage.directory.R"))
outputStorage <- setStorageDir( c(experimentName.recut,"plots","heatmaps" ) )

library(gplots)
# Original DS3 cut
heatmap.module( moduleNames=colnames(MEs), moduleCor=moduleCor, geneInfo=geneList.DS, eset=eset, saveFile=TRUE, 
                deepSplit="DS3-TOM", cexRow = 0.1, cexCol=1.2, margins=c(7,7),
                pngWidth=1800, pngHeight=800)
# DS1 recut
heatmap.module( moduleNames=colnames(MEs.DS1), moduleCor=moduleCor.DS1, geneInfo=geneList.DS1, eset=eset, saveFile=TRUE, 
                deepSplit="DS1", cexRow = 0.1, cexCol=1.2, margins=c(7,7),
                pngWidth=1800, pngHeight=800)

# DS2 recut
heatmap.module( moduleNames=colnames(MEs.DS2), moduleCor=moduleCor.DS2, geneInfo=geneList.DS2, eset=eset, saveFile=TRUE, 
                deepSplit="DS2", cexRow = 0.1, cexCol=1.2, margins=c(7,7),
                pngWidth=1800, pngHeight=800)

# DS3 recut
heatmap.module( moduleNames=colnames(MEs.DS3), moduleCor=moduleCor.DS3, geneInfo=geneList.DS3, eset=eset, saveFile=TRUE, 
                deepSplit="DS3", cexRow = 0.1, cexCol=1.2, margins=c(7,7),
                pngWidth=1800, pngHeight=800)

# DS4 recut
heatmap.module( moduleNames=colnames(MEs.DS4), moduleCor=moduleCor.DS4, geneInfo=geneList.DS4, eset=eset, saveFile=TRUE, 
                deepSplit="DS4", cexRow = 0.1, cexCol=1.2, margins=c(7,7),
                pngWidth=1800, pngHeight=800)

setwd(analysisDir)

########################################################################################
## CORRELATE PROBES/GENES TO ALL CLINICAL TRAITS AND BIND TO GENE LISTS

# 08-02-17 RDR: Inspect the probes with 0 standard deviation!!!
gene.corr.r <- cor(datExpr, datTraits, use = "p")
gene.corr.p <- corPvalueStudent(gene.corr.r, nrow(datExpr))

# Bind correlations to their pvals
colnames(gene.corr.p) <- paste( colnames(gene.corr.p), ".p", sep="" )

alternate.cols <- function(m1, m2) {
  cbind(m1, m2)[, order(c(seq(ncol(m1)), seq(ncol(m2))))]
}
gene.corr.r_p <- alternate.cols(gene.corr.r, gene.corr.p)

setwd(experimentDir)
save(gene.corr.r_p, file="gene_correlations_datTraits.RData")

########################################################################################
## CALCULATE KMEs FOR ALL DEEP SPLITS
# Signed kME is essentially modular membership, meaning the correlation of each probe to the eigengene
# of it's containing module, calculated as MM = as.data.frame(cor(datExpr, MEs, use = "p"));
# Dr. Peter Langfelder writes "There's also a function called signedKME which essentially does the same 
# as your cor() call, but adds a bunch of checks for correct data formatting and for non-varying genes
# or genes with too many missing values."
# See https://support.bioconductor.org/p/69858/

for (i in 1:length(MEs.batch)) {
  print(paste("Calculating kMEs for",MEs.batch[i]))
  KME.DS <- signedKME( datExpr, get(MEs.batch[i]), outputColumnName="KME")
  KME.DS.p <- corPvalueStudent(as.matrix(KME.DS), nSamples=ncol(datTraits))
  
  colnames(KME.DS) <- paste("",colnames(get(MEs.batch[i])),sep="")
  colnames(KME.DS.p) <- paste( colnames(KME.DS), ".p", sep="" )
  
  KME.DS.final <- alternate.cols(KME.DS,KME.DS.p)
  
  assign(paste("KME.",MEs.batch[i],sep=""), KME.DS.final)
  
}

save(KME.MEs,KME.MEs.DS1,KME.MEs.DS2,KME.MEs.DS3,KME.MEs.DS4, file="gene_KMEs.RData")

KME.batch <- c("KME.MEs", "KME.MEs.DS1", "KME.MEs.DS2", "KME.MEs.DS3", "KME.MEs.DS4")

###############
# Generate a frame of the KME the genes were primarily assigned to


for (i in 1:length(KME.batch)) {
  KME.primary <- matrix(nrow=nrow(get(KME.batch[i])),ncol=1)
  KME.corr <- get(KME.batch[i])[,seq(1, ncol(get(KME.batch[i])), 2)]
  print(paste("Calculating kMEs for ",KME.batch[i],sep=""))
  for (j in 1:nrow(geneList.DS)) {
    if (!is.null(KME.corr[i, geneList.DS[j,"moduleColors"] ])) {
      KME.primary[j] <- KME.corr[j, geneList.DS[j,"moduleColors"] ]
      assign(paste("KME.primary",KME.batch[i],sep=""), KME.corr)
    }
  }
}


save(KME.primaryKME.MEs,KME.primaryKME.MEs.DS1,KME.primaryKME.MEs.DS2,KME.primaryKME.MEs.DS3,KME.primaryKME.MEs.DS4, file="gene_primaryKMEs.RData")

########################################################################################
## CALCULATE KIMs FOR ALL DEEP SPLITS
# Calculate kIM, or intramodular connectivity, i.e. connectivity of nodes to other nodes
# within the same module. Note kME and kIM values should be fairly similar, as a strong kME
# correlation of a gene to the eigengene, or strong modular membership, should suggest
# a high degree of connectedness to other intramodular genes, as a hub gene.
# Again, see https://support.bioconductor.org/p/69858/.
#
# 08-04-17 RDR: We used to calculate kIMs per block. See the following script as we need to make 
# sure this new approach using intramodularConnectivity.fromExpr() generates the same results!
# source("/mnt/disks/rserver/projects/CopyOfshared_scripts/wgcna/wgcna.kIMs.per.block.R")

for (i in 1:length(moduleColors.batch)) {
  
  print(paste("Calculating intramodular connectivities for ",moduleColors.batch[i],sep=""))
  
  kIM=intramodularConnectivity.fromExpr(datExpr, get(moduleColors.batch[i]), corFnc = "cor",
                                        corOptions = "use = 'p'",
                                        distFnc = "dist", distOptions = "method = 'euclidean'",
                                        networkType = "signed",
                                        power = as.integer(TOM.settings["power"]),
                                        scaleByMax = TRUE,
                                        ignoreColors = if (is.numeric(colors)) 0 else "grey",
                                        getWholeNetworkConnectivity = TRUE)
  
  assign(paste("kIM.",moduleColors.batch[i],sep=""), kIM)
}

save(kIM.moduleColors,kIM.moduleColors.DS1,kIM.moduleColors.DS2,kIM.moduleColors.DS3,kIM.moduleColors.DS4,
     file="genes_kIMs.RData")

########################################################################################
## PLOT INTRAMODULAR MEMBERSHIP VS. CORRELATION TO CLINICAL TRAIT OF INTEREST

setStorageDir <- dget(paste0(scriptDir,"wgcna/set.storage.directory.R"))
outputStorage <- setStorageDir( c(experimentName.recut,"plots") )

source(paste0(scriptDir,"wgcna/wgcna.plot.module.im.vs.sigtrait-corr.R"))
# n.b. this doesn't plot grey module because there is no kIM data
kIMvsCorrPlot(moduleCor.DS3,moduleColors.DS3,kIM.moduleColors.DS3,DS.tag="DS3")
source(paste0(scriptDir,"wgcna/wgcna.plot.module.me.vs.sigtrait-corr.R"))
kMEvsCorrPlot(moduleCor.DS3,moduleColors.DS3,KME.primaryKME.MEs.DS3,DS.tag="DS3")
source(paste0(scriptDir,"wgcna/wgcna.plot.mes.and.boxplot.R"))
ME_plots(MEs=MEs.DS3,DS.tag="DS3")


########################################################################################
## BRING IT ALL TOGETHER BY BINDING GENEINFO, GENE.CORR.R_P, KME, AND KIM

setwd(experimentDir)

# choose a final deep split to go with

geneList.DS3.final <- cbind(geneList.DS3, gene.corr.r_p, kIM.moduleColors.DS3, KME.MEs.DS3)

write.table(geneList.DS3.final,file="geneList.DS3.final.txt",row.names=TRUE, quote=FALSE, sep="\t")

colnames(geneList.DS3.final)
geneList.DS3.final.simple <- geneList.DS3.final[,1:29] # remove all module name columns

index <- which(is.na(geneList.DS3.final.simple[,"geneEntrezID"]))
geneList.DS3.final.simple <- geneList.DS3.final.simple[-index,]

write.table(geneList.DS3.final.simple,file="geneList.DS3.final.simple.txt",row.names=FALSE, quote=FALSE, sep="\t")

# index <- which(geneList.DS.final.simple[,"moduleColors"]==c("lightyellow","brown"))
# 
# geneList.DS.final.simple.lightyellow.brown <- geneList.DS.final.simple[index,]
# 
# write.table(geneList.DS.final.simple.lightyellow.brown,file="geneList.DS.final.simple.lightyellow.brown.txt",row.names=TRUE, quote=FALSE, sep="\t")

save(moduleCor.DS3,geneList.DS3.final.simple,file="final_results.DS3.RData")
write.table(moduleCor.DS3,file="moduleCor.DS3.txt",row.names=TRUE, quote=FALSE, sep="\t")
